/* ************************************************************************** */
/* * bcnrand.h                                                              * */
/* * Copyright (C) 2012 Deakin University                                   * */
/* * Authors: Gleb Beliakov, Tim Wilkin, Michael Johnstone                  * */
/* * Created: 08/06/12     Last Modified: 27/04/14                          * */
/* ************************************************************************** */
/*	Description:
	This is the C language version of the library bcnrandom, which  generates
	uniform random variates of type double on (0,1), using the linear
	Congruential Generator (LCG) by J. Borwein and D. Bailey. 

	Random variates are generated in parallel on GPU (with Nvidia's CUDA).
	This is version 2 of this library. Version 2 no longer has the original 
	BCN method, as the method based on Barrett reduction is superior. This 
	version no longer uses double-double implementation of the seeding step, 
	as a more efficient implementation was found. 

 	The random variates are generated by iterating
	                       z_{k+1} = 2^53 z_k mod 3^33. 
	The actual random variate is computed by 
	                            x = z_{k+1} * 3^-33. 
	The period is approx 10^15. Random variates can be generated in parallel 
	and in multiple threads, although this version of the code is not always
	guaranteed to be thread safe, see notes below.

	A combined LCG is also used to ensure even better statistical quality
	of the generated sequence. The combined generator is marginally slower than
	J. Borwein and D. Bailey's LCG, but gives a longer period and passes
	Birthday spacings and Closed pairs tests as well.

	The pseudorandom sequence passes the statistical tests of BigCrunch test of
	TestU01 suite. The description of the method is published in:

	Beliakov, G., Creighton, D., Johnstone, M. and Wilkin, T. 2013, Efficient implementation 
	of Bailey and Borwein pseudo-random number generator based on normal numbers, 
	Computer physics communications, vol. 184, no. 8, pp. 1999-2004.

	G. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, 2012, An efficient implementation of 
	Bailey and Borwein's algorithm for parallel random number generation on graphics processing
	units, Computing 94(5): 433-447.

	G. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, Parallel random
	variates generator for GPUs based on normal numbers, ArXiv 1206.1187
	http://arxiv.org/abs/1206.1187,
	see also	http://www.deakin.edu.au/~gleb/bcn_random.html

	
	Usage: Follow the examples presented here.
	
	bcnrand offers two alternative methods for generating random variates 
	BCN and Combined. 

		BCN is the method based on our modified Barrett reduction.
		Combined is the method that used BCN and an auxiliary LCG 

		The user desires to generate a sequence of pseudorandom variates starting 
		from a chosen position (seed), using a number of parallel threads. Each 
		thread generates part of the sequence. The random variates are either 
		written to global memory, or used for any task, such as simulation.

     Step 1 is to generate an array of starting positions for each thread 
	 (seeds). It is accomplished by calling 
			dim3 dimBlock(numThreadsPerBlock, 1, 1);
			dim3 dimGrid(numBlocks, 1, 1);
			Kernel_initGenerator<<< dimGrid, dimBlock >>>(d_SeedData, workPerThread, seed);

		workPerThread is a parameter that specifies the length of the subsequence 
		of random variates for each thread.
		It is calculated as workPerThread = TotalNumOfElements/numBlocks/numThreadsPerBlock;
		NOTE that the parameter "seed" is the starting position of the first element of the sequence 

     Step 2 is to generate random variates. It is accomplished by calling kernels with this code:
			//get starting seed
			uint64_t seed = (uint64_t)d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];
    			for (int i = 0 ; i < WorkPerThread ; i++)
   			{		
				generated_value=bcnrandom_inline(&seed);
        	}
		bcnrandom_inline can be replaced by randCombined(&seed, &seed1);	

		See example kernels Kernel_CountValues, (Kernel_CountValues_Combined), which are used to
		calculate the number of random variates smaller than 0.9. These kernels are invoked by calling
		
			Kernel_CountValues<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, workPerThread);
		where d_SeedData are precomputed at Step 1 seeds, and d_OutputData is the array of unsigned int of length numblocks.
		The complete code is in function InlineGeneration

		This kernel will use the combined generator, which has better statistical properties
		    Kernel_CountValues_Combined<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, d_SeedData1, workPerThread);

	      To write generated values to global memory, see function TimeBarrettMethod. 



	List of functions:
		bcnrandom_inline, randCombined  - two methods called by kernels that actually perform generation steps

		Kernel_CountValues, Kernel_CountValues_Combined - example kernels that count the number
			of generated values smaler than 0.9. They call their respective methods from the list above, and multiply
			the returned values by 3^-33, then use the result

		Kernel_initGenerator - initialises the array of seeds (for each thread)

		Kernel_initGeneratorCombined - initialises the two arrays of seeds (for the bcn and the auxiliary generator)
			(for each thread)

		InlineGeneration - shows how to use the functions above

		Kernel_Opt   - example kernel that writes generated values to an array in global memory 

		TimeBarrettMethod - shows how to use the example kernels and times its execution, then prints the results
			

	Example and main file:
		See file bcnrand.cu

	This program is freeware.


	Please cite our work
	Beliakov, G., Creighton, D., Johnstone, M. and Wilkin, T. 2013, Efficient implementation of Bailey and Borwein 
	pseudo-random number generator based on normal numbers, 
	Computer physics communications, vol. 184, no. 8, pp. 1999-2004.

	G. Beliakov, M. Johnstone, D. Creighton, T. Wilkin, 2012, An efficient implementation of 
	Bailey and Borwein's algorithm for parallel random number generation on graphics processing
	units, Computing 94(5): 433-447.

	http://arxiv.org/abs/1206.1187, http://www.deakin.edu.au/~gleb/bcn_random.html

	J. Borwein and D. Bailey's work is available from:
	http://crd.lbl.gov/~dhbailey/dhbpapers/normal-pseudo.pdf

	Copyright Gleb Beliakov, Tim Wilkin and Michael Johnstone, 2013
**************************************************************************************************************/

#ifndef BCNRANDGPU_H
#define BCNRANDGPU_H



typedef long long int64_tt ;
typedef unsigned long long uint64_t ;

using std::string;
using std::vector;


#include "bcnrand.inl"


/*	
 * bcnrandom_inline
 * The inline  kernel - generates the next random number in the sequence based on the provided seed
 */
__device__ inline double bcnrandom_inline(uint64_t* seed)
{
	uint64_t qhi, qlo, r2lo;
	
	return BCN_minv * barrett_step_opt(*seed);	
}


/*	
 * randCombined
 * The combined generator kernel - generates the next random number in the sequence based on the provided seeds
 */
__device__ __inline__ double randCombined(uint64_t  * s, uint64_t  * s1)
{
	uint64_t rnd = randCombined_increment(s, s1);
	
	if (rnd == 0)
		return LCG_m1*LCG_m_inv;
	else
		return rnd*LCG_m_inv;
}

/*	
 * Kernel_initGenerator
 * This kernel initialises the starting seed for each thread and writes them back to device global memory
 * Parameters: 
 *	md_SeedData: output, contains precomputed seeds for each thread
 *	WorkPerThread: input, length of each subsequence 
 *	Seed: input, starting position
 */
__global__ void Kernel_initGenerator(uint64_t *md_SeedData, unsigned int WorkPerThread, uint64_t Seed)
{
	int tid = threadIdx.x + threadIdx.y * blockDim.x;
	int gid = blockIdx.x * blockDim.x * blockDim.y * WorkPerThread + WorkPerThread * tid;

	//find my seed
	Seed += 53.0 * gid;

	md_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid] = BarrettInitBit(Seed);
}




/*	
 * Kernel_initGeneratorCombined
 * This kernel initialises the starting seed for each thread and writes them back to device global memory
 * Parameters: 
 *	md_SeedData,md_SeedData1: output, contains precomputed seeds for each thread
 *	WorkPerThread: input, length of each subsequence 
 *	Seed: input, starting position
 */
__global__ void Kernel_initGeneratorCombined(uint64_t *md_SeedData, uint64_t *md_SeedData1, unsigned int WorkPerThread, uint64_t Seed)
{
	int tid = threadIdx.x + threadIdx.y * blockDim.x;
	int gid = blockIdx.x * blockDim.x * blockDim.y * WorkPerThread + WorkPerThread * tid;
	int Seed1=Seed;

	//find my seed
	Seed += 53.0 * gid;
	Seed1+= gid;

	seedCombined(Seed, Seed1, &(md_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid]),  &(md_SeedData1[blockIdx.x * blockDim.x * blockDim.y + tid]));
}



/* ============================================================================================== */
/* The methods below are essentially illustrative examples of how bcnrandom_inline() can be used */

/*	
 * Kernel_CountValues
 * This kernel shows how to use the bcnrandom method inline
 * Parameters: 
 * 	results: 	output, contains calculated values
 *	d_SeedData: input, contains precomputed seeds for each thread
 *	WorkPerThread: input, length of each subsequence 
 */
__global__ void Kernel_CountValues(unsigned int * const results, int64_tt *d_SeedData, const unsigned int WorkPerThread)
{
	extern __shared__ unsigned int sdata[];
	
    unsigned int tid = blockIdx.x * blockDim.x + threadIdx.x;
	
	//get starting seed
	uint64_t seed = (uint64_t)d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];
	
    // Count the number of numbers less than 0.9
    unsigned int count = 0;
    for (int i = 0 ; i < WorkPerThread ; i++)
    {
        if( bcnrandom_inline(&seed)<0.9 )
            count++;
    }

    sdata[threadIdx.x] = count;
    __syncthreads();

    // add the result slowly!
    if (threadIdx.x == 0)
    {
    	for (int i = 1 ; i < blockDim.x ; i++) 
	    	count += sdata[i];
        
        results[blockIdx.x] = count;
    }
}


/*	
 * Kernel_Opt
 * This kernel generates random numbers using the optmised bcn method and writes them back to device global memory
 * Parameters: 
 * 	d_OutputData: 	output, contains calculated random variates
 *	d_SeedData: 	input, contains precomputed seeds for each thread
 *	WorkPerThread: 	input, length of each subsequence 
 */
__global__ void Kernel_Opt(double *d_OutputData, int64_tt *d_SeedData, unsigned int WorkPerThread)
{
    int tid = threadIdx.x + threadIdx.y * blockDim.x;
	int gid = blockIdx.x * blockDim.x * blockDim.y * WorkPerThread + tid;
	int step = blockDim.x * blockDim.y;
	int istep;
	
	uint64_t qhi, qlo, r2lo, rlo;
	
	//get starting seed
	rlo = (uint64_t)d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];

	//Calculate successive members of sequence.
	for(int i = 0; i < WorkPerThread; i+=8)
	{
		istep = gid+i*step;
		
		barrett_step_opt(rlo);	
		d_OutputData[istep] = BCN_minv * rlo;
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step] = BCN_minv *  rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*2] = BCN_minv *  rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*3] = BCN_minv * rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*4] = BCN_minv * rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*5] = BCN_minv * rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*6] = BCN_minv * rlo;			
		
		barrett_step_opt(rlo);
		d_OutputData[istep+step*7] = BCN_minv * rlo;
	}
}

/*	
 * Kernel_Constant_Unrolled
 * This kernel calculates the maximum generation rate by simple writing values back to device global memory
 * Used for benchmarking purposes only
 * Parameters: 
 * 	d_OutputData: 	output, contains just a constant value
 *	d_SeedData: 	input, contains precomputed seeds for each thread
 *	WorkPerThread: 	input, length of each subsequence 
 */
__global__ void Kernel_Constant_Unrolled(double *d_OutputData, double *d_SeedData, unsigned int WorkPerThread)
{
    int tid = threadIdx.x + threadIdx.y * blockDim.x;
	int gid = blockIdx.x * blockDim.x * blockDim.y * WorkPerThread + tid;
	int step = blockDim.x * blockDim.y;
	
	double rlo;
	int istep;
	
	//get starting seed
	rlo = d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];

	//Calculate successive members of sequence.
	for(int i = 0; i < WorkPerThread; i+=8)
	{
		istep = gid+i*step;
		
		d_OutputData[istep] = rlo;
		d_OutputData[istep+step] = rlo;		
		d_OutputData[istep+step*2] = rlo;		
		d_OutputData[istep+step*3] = rlo;		
		d_OutputData[istep+step*4] = rlo;			
		d_OutputData[istep+step*5] = rlo;			
		d_OutputData[istep+step*6] = rlo;			
		d_OutputData[istep+step*7] = rlo;
	}
}

/*	
 * InlineGeneration
 * This function shows how to use BCN_RAND as an inline generator.
 * In this example a count of all the values under 0.9 is written to the screen
 * Parameters: 
 * 	numElements: 	input, number of random variates to generate
 *	seed: 		input, the starting position of the sequence plus 3^33+100
 * 	numThreadsPerBlock: input, >0, typically 512 or 256
 *	numBlocks:		input, >0
 *	workPerThread: 	input, length of each subsequence 
 */
void InlineGeneration(unsigned int numElements, double seed, unsigned int numThreadsPerBlock, unsigned int numBlocks, unsigned int workPerThread)
{
	//allocate mem for the result on device side
	//GPU seed data
	int64_tt *d_SeedData;	
	cudaMalloc((void **)&d_SeedData, numBlocks*numThreadsPerBlock*sizeof(int64_tt));
	//GPU results data
	unsigned int *d_OutputData; 
    cudaMalloc((void **)&d_OutputData, numBlocks * sizeof(unsigned int));
    
	dim3 dimBlock(numThreadsPerBlock, 1, 1);
	dim3 dimGrid(numBlocks, 1, 1);
	
	//Init Generators
	Kernel_initGenerator<<< dimGrid, dimBlock >>>(d_SeedData, workPerThread, seed);
	
	double value;
	vector<unsigned int> results(dimGrid.x);
	
	
	//Barrett
	//Count the points less than 0.9
    Kernel_CountValues<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, workPerThread);
	//Copy counts from each block back
	cudaMemcpy(&results[0], d_OutputData, dimGrid.x * sizeof(unsigned int), cudaMemcpyDeviceToHost);
    //Complete sum reduction on host
    value = static_cast<double>(std::accumulate(results.begin(), results.end(), 0));
	printf("Bcn_random: Value = %.0f, %.2f%% of values less than 0.9.\n",value, 100*value/numElements);
	
    //free device mem
	cudaFree(d_SeedData);
	cudaFree(d_OutputData);
	
    cudaThreadExit();
}



/*	
 * TimeBCNMethod
 * This function shows how to use the BCN Method and writes the generated values to device global memory.
 * This function also calculates the generation rate of the method.
 * Parameters: 
 * 	numElements: 	input, number of random variates to generate
 *	seed: 		input, the starting position of the sequence plus 3^33+100
 * 	numThreadsPerBlock: input, >0, typically 512 or 256
 *	numBlocks:		input, >0
 * 	numIterations:	input, >0, how many times to repeat the procedure to collect CPU time
 *	workPerThread: 	input, length of each subsequence 
 */
void TimeBCNMethod(unsigned int numElements, double seed, unsigned int numThreadsPerBlock, unsigned int numBlocks, unsigned int numIterations, unsigned int workPerThread)
{
	//setup timers
	float setupTime;
	float executeTime;
	float executeTimeSum;
	
	cudaEvent_t setupStart;
    cudaEvent_t setupEnd;
    cudaEvent_t executeStart;
    cudaEvent_t executeEnd;
    
    cudaEventCreate(&setupStart);
	cudaEventCreate(&setupEnd);
	cudaEventCreate(&executeStart);
	cudaEventCreate(&executeEnd);
	
	//allocate mem for the result on device side
	double *d_OutputData;	//GPU output data
	int64_tt *d_SeedData;	//GPU output data
	cudaMalloc((void **)&d_OutputData, numElements*sizeof(double));
	cudaMalloc((void **)&d_SeedData, numBlocks*numThreadsPerBlock*sizeof(double));
	
	dim3 dimBlock(numThreadsPerBlock, 1, 1);
	dim3 dimGrid(numBlocks, 1, 1);
	
	//init seeds
	cudaEventRecord(setupStart, 0);
	Kernel_initGenerator<<< dimGrid, dimBlock >>>(d_SeedData, workPerThread,  seed);
	cudaEventRecord(setupEnd, 0);
	cudaEventSynchronize(setupEnd);
	cudaEventElapsedTime(&setupTime, setupStart, setupEnd);
	
	executeTimeSum = 0;
	for(unsigned int i = 0; i < numIterations; i++) 
    {
	    executeTime = 0;
		cudaEventRecord(executeStart, 0);
		
		//execute the kernel
		Kernel_Opt<<< dimGrid, dimBlock >>>(d_OutputData, d_SeedData, workPerThread);
		
		cudaEventRecord(executeEnd, 0);
		cudaEventSynchronize(executeEnd);
		cudaEventElapsedTime(&executeTime, executeStart, executeEnd);
		executeTimeSum +=executeTime;
	}
	
	//free device mem
	cudaFree(d_OutputData);
	cudaFree(d_SeedData);
	
	//free timers
	cudaEventDestroy(setupStart);
	cudaEventDestroy(setupEnd);
	cudaEventDestroy(executeStart);
	cudaEventDestroy(executeEnd);
	
	//Print Results
	printf("BCN method, %f GNum/Sec, %f ms Execute Time, %f ms Setup Time\n", (1/(executeTimeSum/(numIterations*1.0)))*1000*numElements/1000000000, executeTimeSum/(numIterations*1.0), setupTime);
}



/*  ==============================Illustrations how to use the combined generator  =================================*/



/*	
 * Kernel_CountValues_Combined
 * This kernel shows how to use the Combined method 
 * Parameters: 
 * 	results: 	output, contains calculated values
 *	d_SeedData, d_SeedData1: input, contains precomputed seeds for each thread
 *	WorkPerThread: input, length of each subsequence 
 */
__global__ void Kernel_CountValues_Combined(unsigned int * const results, int64_tt *d_SeedData, int64_tt *d_SeedData1, const unsigned int WorkPerThread)
{
	extern __shared__ unsigned int sdata[];
	
    unsigned int tid = blockIdx.x * blockDim.x + threadIdx.x;
	
	//get starting seed
	uint64_t seed = (uint64_t)d_SeedData[blockIdx.x * blockDim.x * blockDim.y + tid];
	//get starting seed (we need two seeds)
	uint64_t seed1 = (uint64_t)d_SeedData1[blockIdx.x * blockDim.x * blockDim.y + tid];
	
    // Count the number of numbers less than 0.9
    unsigned int count = 0;
    for (int i = 0 ; i < WorkPerThread ; i++)
    {
        if( randCombined(&seed, &seed1)<0.9 )
            count++;
    }

    sdata[threadIdx.x] = count;
    __syncthreads();

    // add the result slowly!
    if (threadIdx.x == 0)
    {
    	for (int i = 1 ; i < blockDim.x ; i++) 
	    	count += sdata[i];
        
        results[blockIdx.x] = count;
    }
}


/*	
 * GenerationCombined
 * This function shows how to use the combined inline generator.
 * In this example a count of all the values under 0.9 is written to the screen
 * Parameters: 
 * 	numElements: 	input, number of random variates to generate
 *	seed: 		input, the starting position of the sequence plus 3^33+100
 * 	numThreadsPerBlock: input, >0, typically 512 or 256
 *	numBlocks:		input, >0
 *	workPerThread: 	input, length of each subsequence 
 */
void GenerationCombined(unsigned int numElements, double seed, unsigned int numThreadsPerBlock, unsigned int numBlocks, unsigned int workPerThread)
{
	//allocate mem for the result on device side
	//GPU seed data
	int64_tt *d_SeedData;	
	cudaMalloc((void **)&d_SeedData, numBlocks*numThreadsPerBlock*sizeof(int64_tt));
	// for the aux generator
	int64_tt *d_SeedData1;	
	cudaMalloc((void **)&d_SeedDat1a, numBlocks*numThreadsPerBlock*sizeof(int64_tt));	
	
	//GPU results data

	unsigned int *d_OutputData; 
    cudaMalloc((void **)&d_OutputData, numBlocks * sizeof(unsigned int));
    
	dim3 dimBlock(numThreadsPerBlock, 1, 1);
	dim3 dimGrid(numBlocks, 1, 1);
	
	//Init Generators

	Kernel_initGeneratorCombined<<< dimGrid, dimBlock >>>(d_SeedData, d_SeedData1, workPerThread, seed);
	
	double value;
	vector<unsigned int> results(dimGrid.x);
	
	//Count the points less than 0.9
    Kernel_CountValues_Combined<<<dimGrid, dimBlock, dimBlock.x * sizeof(unsigned int)>>>(d_OutputData, d_SeedData, d_SeedData1, workPerThread);
	//Copy counts from each block back
	cudaMemcpy(&results[0], d_OutputData, dimGrid.x * sizeof(unsigned int), cudaMemcpyDeviceToHost);
    //Complete sum reduction on host
    value = static_cast<double>(std::accumulate(results.begin(), results.end(), 0));
	printf("Combined: Value = %.0f, %.2f%% of values less than 0.9.\n",value, 100*value/numElements);
	
    //free device mem
	cudaFree(d_SeedData);
	cudaFree(d_SeedData1);
	cudaFree(d_OutputData);
	
    cudaThreadExit();
}







#endif